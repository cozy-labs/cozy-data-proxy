/* @flow */
/* eslint-env mocha */

const _ = require('lodash')
const sinon = require('sinon')
const should = require('should')

const Merge = require('../../core/merge')
const metadata = require('../../core/metadata')
const { otherSide } = require('../../core/side')

const configHelpers = require('../support/helpers/config')
const {
  onPlatform,
  onPlatforms
} = require('../support/helpers/platform')
const pouchHelpers = require('../support/helpers/pouch')
const dbBuilders = require('../support/builders/db')
const Builders = require('../support/builders')

/** Resolves with an object describing the side-effects of a Merge call.
 *
 * The returned object has the following properties:
 *
 * - `savedDocs`: Which docs were changed in `Pouch`
 * - `resolvedConflicts`: Which conflits were resolved on which side
 */
async function mergeSideEffects ({merge, pouch} /*: * */, mergeCall /*: () => Promise<*> */) {
  const { last_seq: lastSeq } = await pouch.db.changes({since: 'now'})

  sinon.spy(merge, 'resolveConflictAsync')

  await mergeCall()

  const opts = {since: lastSeq, include_docs: true}
  const { results } = await pouch.db.changes(opts)
  const savedDocs = results.map(({doc}) => {
    // Don't include _rev in assertions: they are randomly generated by Pouch,
    // which makes them hard to compare.
    delete doc._rev

    return doc
  })

  return {
    savedDocs,
    resolvedConflicts: merge.resolveConflictAsync.args.map(([side, doc, existing]) =>
      [
        side,
        // Include only properties that are relevant in conflict resolution:
        _.pick(doc, [
          // The path is necessary to:
          // - generate the new file/dir name including the conflict suffix.
          // - rename the conflicting file/dir on the local side.
          'path',
          // The remote._id is necessary to rename the conflicting file/dir on
          // the remote side. Actually the remote._rev is not used although
          // we're currently including it in the test-asserted data as part of
          // the remote property.
          'remote'
        ])
        // Don't include the existing version: it is only useful for
        // logging / debugging and has no impact on conflict resolution.
      ]
    )
  }
}

describe('Merge', function () {
  let builders

  before('instanciate config', configHelpers.createConfig)
  beforeEach('instanciate pouch', pouchHelpers.createDatabase)
  beforeEach('instanciate merge', function () {
    this.side = 'local'
    this.merge = new Merge(this.pouch)
    this.merge.local = {renameConflictingDocAsync: sinon.stub().resolves()}
    this.merge.remote = {renameConflictingDocAsync: sinon.stub().resolves()}
    builders = new Builders({pouch: this.pouch})
  })
  afterEach('clean pouch', pouchHelpers.cleanDatabase)
  after('clean config directory', configHelpers.cleanConfig)

  describe('addFile', function () {
    it('saves the new file', async function () {
      const doc = builders
        .metafile()
        .path('new-file')
        .data('content')
        .tags('courge', 'quux')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the path was used in the past', function () {
      const path = 'file-created-deleted-and-then-recreated'

      beforeEach(async function () {
        const was = await builders
          .metafile()
          .path(path)
          .data('content')
          .create()
        await this.pouch.remove(was)
      })

      it('saves the new file with the correct side number', async function () {
        const expectedRevNumber = 4 // create + delete + create + update side

        const doc = builders.metafile().path(path).data('file content').build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber }
                // TODO: Compare _revs
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a file with the same path exists', function () {
      let file

      beforeEach('create a file', async function () {
        file = await builders
          .metafile()
          .path('BUZZ.JPG')
          .data('image')
          .tags('foo')
          .type('image/jpeg')
          .ino(123)
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
      })

      it('can update the metadata', async function () {
        const doc = builders.metafile(file).tags('bar', 'baz').build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                tags: ['bar', 'baz'],
                sides: { [this.side]: 3, [otherSide(this.side)]: 2 }
              },
              _.omit(file, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('resolves an identity conflict with an existing file', async function () {
        await builders.metafile().path('bar').upToDate().create()
        const doc = builders.metafile().path('BAR').remoteId(dbBuilders.id()).build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, _.pick(doc, ['path', 'remote'])]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not have identity conflicts', async function () {
        await builders.metafile().path('bar').create()
        const doc = builders.metafile().path('BAR').build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { [this.side]: 1 }
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('resolves a conflict with an existing dir', async function () {
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    it('does nothing for an already merged file (aka idempotence)', async function () {
      const mergedFile = await builders.metafile().sides({remote: 1}).create()
      const sameFile = builders.metafile(mergedFile).unmerged('remote').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('resolves a conflict on remote file addition with unsynced local file addition', async function () {
      const unsyncedLocalFile = await builders
        .metafile()
        .sides({ local: 1 })
        .noRemote()
        .data('local content')
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(unsyncedLocalFile.path)
        .unmerged('remote')
        .data('remote content')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    context('on initial scan', function () {
      it('overrides an unsynced local addition with a local update', async function () {
        const initialFile = await builders
          .metafile()
          .sides({ local: 1 })
          .ino(123)
          .noRemote()
          .data('initial content')
          .create()
        const offUpdate = await builders
          .metafile(initialFile)
          .unmerged('local')
          .data('off update')
          .newerThan(initialFile)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(offUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { local: 2 }
              },
              _.pick(offUpdate, ['md5sum', 'size', 'updated_at']),
              _.omit(initialFile, ['_rev', 'remote']) // FIXME: Compare _revs, stop mixing undefined and missing remote
            )
          ],
          resolvedConflicts: []
        })
      })

      it('overrides an unsynced local update with a new one', async function () {
        const initial = await builders
          .metafile()
          .path('yafile')
          .sides({ local: 1 })
          .ino(37)
          .data('initial content')
          .create()
        const synced = await builders
          .metafile(initial)
          .sides({ local: 2, remote: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const firstUpdate = await builders
          .metafile(synced)
          .sides({ local: 3, remote: 2 })
          .data('first update')
          .create()
        const secondUpdate = builders
          .metafile(firstUpdate)
          .unmerged('local')
          .data('second update')
          .newerThan(firstUpdate)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(secondUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: { [this.side]: 4 }
              },
              _.pick(secondUpdate, ['md5sum', 'size', 'updated_at']),
              _.omit(firstUpdate, ['_rev']) // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves a conflict between an unchanged file & an unsynced remote update', async function () {
        const initial = await builders
          .metafile()
          .sides({ local: 1 })
          .data('previous content')
          .create()
        const synced = await builders
          .metafile(initial)
          .sides({ local: 2, remote: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const remoteUpdate = await builders
          .metafile(synced)
          .sides({ local: 2, remote: 3 })
          .data('remote update')
          .create()
        const sameAsSynced = builders
          .metafile(synced)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(sameAsSynced))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            ['local', _.pick(remoteUpdate, ['path', 'remote'])]
          ]
        })
      })

      it('resolves a conflict between a local update & an already merged remote update', async function () {
        const initial = await builders
          .metafile()
          .sides({ local: 1 })
          .data('initial content')
          .create()
        const synced = await builders
          .metafile(initial)
          .sides({ local: 2, remote: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const remoteUpdate = await builders
          .metafile(synced)
          .sides({ local: 2, remote: 3 })
          .data('remote update')
          .create()
        const localUpdate = builders
          .metafile(synced)
          .unmerged('local')
          .data('local update')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(localUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            ['local', _.pick(remoteUpdate, ['path', 'remote'])]
          ]
        })
      })
    })
  })

  describe('updateFile', () => {
    let file

    beforeEach('create synced file', async function () {
      file = await builders
        .metafile()
        .path('FIZZBUZZ.JPG')
        .ino(3456)
        .data('image')
        .type('image/jpeg')
        .tags('foo')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
    })

    it('creates the file if it does not exist', async function () {
      const doc = builders
        .metafile()
        .path('NEW-FILE')
        .data('content')
        .tags('courge', 'quux')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('updates the metadata when content is the same', async function () {
      const doc = builders.metafile(file).tags('bar', 'baz').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 3, remote: 2 }
            },
            _.pick(doc, ['tags', 'updated_at']),
            _.omit(file, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    it('overwrite the content when it was changed', async function () {
      const doc = builders
        .metafile(file)
        .data('new content')
        .tags('qux', 'quux')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 3, remote: 2 }
            },
            _.pick(doc, ['md5sum', 'size', 'tags', 'updated_at']),
            _.omit(file, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    it('rejects an unresolvable conflict with an existing directory', async function () {
      // FIXME: Why don't we resolve the conflict like everywhere else?
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      await should(
        this.merge.updateFileAsync('local', _.cloneDeep(newRemoteFile))
      ).be.rejectedWith(/conflict/)
    })

    it('resolves a conflict between a new remote update and a previous local version', async function () {
      const initial = await builders
        .metafile()
        .sides({ local: 1 })
        .ino(456)
        .data('initial content')
        .create()
      const synced = await builders
        .metafile(initial)
        .sides({ local: 2, remote: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const mergedLocalUpdate = await builders
        .metafile(synced)
        .sides({ local: 3, remote: 2 })
        .data('local update')
        .create()
      const newRemoteUpdate = builders
        .metafile(synced)
        .unmerged('remote')
        .data('remote update')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', _.cloneDeep(newRemoteUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { local: 4 }
            },
            // TODO: Compare _revs
            _.omit(mergedLocalUpdate, ['_rev', 'remote']) // We're dissociating the local doc from the remote doc
          )
        ],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteUpdate, ['path', 'remote'])]
        ]
      })
    })

    it('resolves a conflict between a new local update and a previous remote one', async function () {
      const initial = await builders
        .metafile()
        .sides({ local: 1 })
        .data('initial content')
        .create()
      const synced = await builders
        .metafile(initial)
        .sides({ local: 2, remote: 2 })
        .remoteId(dbBuilders.id())
        .create()
      await builders
        .metafile(synced)
        .sides({ local: 2, remote: 3 })
        .data('remote update')
        .create()
      const newLocalUpdate = builders
        .metafile(synced)
        .unmerged('local')
        .data('local update')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(newLocalUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          [
            'local',
            _.defaults(
              _.pick(synced, ['remote']),
              _.pick(newLocalUpdate, ['path'])
            )
          ]
        ]
      })
    })

    it('does nothing when existing file is up to date', async function () {
      const initial = await builders
        .metafile()
        .sides({ [this.side]: 1 })
        .data('initial content')
        .create()
      const initialSynced = await builders
        .metafile(initial)
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const update = await builders
        .metafile(initialSynced)
        .sides({ [this.side]: 3, [otherSide(this.side)]: 2 })
        .data('updated content')
        .create()
      const updateSynced = await builders
        .metafile(update)
        .sides({ [this.side]: 4, [otherSide(this.side)]: 4 })
        .create()
      const sameUpdate = builders
        .metafile(updateSynced)
        .sides(update.sides)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(sameUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })
  })

  describe('putFolder', () => {
    it('saves the new folder', async function () {
      const doc = builders
        .metadir()
        .path('NEW-FOLDER')
        .sides({ [this.side]: 1 })
        .tags('courge', 'quux')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('saves a new version of an existing folder', async function () {
      const old = await builders
        .metadir()
        .path('existing-folder')
        .sides({ [this.side]: 1 })
        .create()
      const doc = builders
        .metadir(old)
        .whateverChange()
        .changedSide(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 2 }
            },
            _.omit(doc, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the path was used in the past', function () {
      const path = 'folder-created-deleted-and-then-recreated'

      beforeEach(async function () {
        const was = await builders.metadir().path(path).sides({ [this.side]: 1 }).create()
        await this.pouch.remove(was)
      })

      it('saves the new folder with the correct side number', async function () {
        const expectedRevNumber = 4 // create + delete + create + update side
        const doc = builders.metadir().path(path).build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber }
              },
              _.omit(doc, ['_rev']) // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does nothing when existing folder is up to date', async function () {
      const old = await builders.metadir().path('up-to-date-folder').create()
      const doc = builders.metadir(old).build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('resolves a conflict with an existing file', async function () {
      const existingLocalFile = await builders
        .metafile()
        .sides({ local: 1 })
        .create()
      const newRemoteDir = builders
        .metadir()
        .path(existingLocalFile.path)
        .sides({ remote: 1 })
        .remoteId(dbBuilders.id())
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', _.cloneDeep(newRemoteDir))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteDir, ['path', 'remote'])]
        ]
      })
    })

    context('when doc can have an identity conflict with an existing dir', () => {
      let Alfred

      beforeEach(async function () {
        await builders
          .metadir()
          .path('alfred')
          .sides({ local: 1 })
          .create()
        Alfred = await builders
          .metadir()
          .path('Alfred')
          .sides({ remote: 1 })
          .remoteId(dbBuilders.id())
          .build()
      })

      onPlatforms(['win32', 'darwin'], () => {
        it('resolves the conflict', async function () {
          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.putFolderAsync('local', _.cloneDeep(Alfred))
          )

          should(sideEffects).deepEqual({
            savedDocs: [],
            resolvedConflicts: [
              ['local', _.pick(Alfred, ['path', 'remote'])]
            ]
          })
        })
      })

      onPlatform('linux', () => {
        it('saves the doc as a new doc', async function () {
          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.putFolderAsync('local', _.cloneDeep(Alfred))
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaultsDeep(
                {
                  sides: { local: 1 }
                },
                Alfred
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })
  })

  describe('moveFileAsync', function () {
    beforeEach('create parent folder', async function () {
      await builders.metadir().path('FOO').upToDate().create()
    })

    it('saves the new file and deletes the old one with move hints for writers', async function () {
      const was = await builders
        .metafile()
        .path('FOO/OLD')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .data('content')
        .tags('courge', 'quux')
        .create()
      const doc = builders
        .metafile(was)
        .path('FOO/NEW')
        .noRev()
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrc
            },
            _.pick(doc, ['_id', 'path', 'updated_at']),
            _.omit(was, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    it('adds missing fields', async function () {
      const was = await builders
        .metafile()
        .path('FOO/OLD-MISSING-FIELDS.JPG')
        .ino(3854)
        .data('image')
        .type('image/jpeg')
        .tags('courge', 'quux')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const doc = builders
        .metafile()
        .path('FOO/NEW-MISSING-FIELDS.JPG')
        .data('image')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrc
            },
            _.pick(was, ['size', 'ino', 'remote']),
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the destination exists', () => {
      let existing

      beforeEach(async function () {
        existing = await builders.metafile().path('DST_FILE').create()
      })

      it('resolves a conflict', async function () {
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const doc = builders
          .metafile(was)
          .path(existing.path)
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        const {_id: dstId, path: dstPath} = _.find(
          sideEffects.savedDocs,
          ({path}) => path.match(/conflict/)
        )

        const movedSrc = _.defaults(
          {
            moveTo: dstId,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                _id: dstId,
                path: dstPath,
                sides: { [this.side]: 1 },
                moveFrom: movedSrc
              },
              doc
            )
          ],
          resolvedConflicts: [
            [this.side, {path: doc.path, remote: doc.remote}]
          ]
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_FILE'

      beforeEach(async function () {
        const previous = await builders.metafile().path(path).create()
        await this.pouch.remove(previous)
      })

      it('saves the new file with the correct side', async function () {
        const expectedRevNumber = 4 // create + delete + create + update side

        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const doc = builders
          .metafile(was)
          .path(path)
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc._id,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber },
                moveFrom: movedSrc
              },
              doc
              // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('identifies a local move without existing remote side as an addition', async function () {
      const was = await builders
        .metafile()
        .path('FOO/OLD')
        .data('content')
        .tags('courge', 'quux')
        .sides({ local: 1 })
        .create()
      const doc = builders
        .metafile()
        .path('FOO/NEW')
        .data('content')
        .tags('courge', 'quux')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { local: 2 },
              _deleted: true
            },
            _.omit(was, ['_rev']) // TODO: Compare _revs
          ),
          _.defaults(
            {
              sides: { local: 1 }
            },
            doc
            // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    it('does not identify the child move of a file following another unsynced move as an addition', async function () {
      const orig = await builders
        .metafile()
        .path('SRC/FILE')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const was = await builders
        .metafile()
        .path('SRC/FILE2')
        .moveFrom(orig)
        .sides({ [this.side]: 3, [otherSide(this.side)]: 2 })
        .create()
      const doc = await builders
        .metafile()
        .path('DST/FILE2')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          // FIXME: missing deleted SRC document due to fake directory move
          {
            _id: 'DST',
            path: 'DST',
            docType: 'folder',
            sides: { [this.side]: 1 },
            tags: [],
            updated_at: doc.updated_at // XXX: It might fail if it takes longer to run moveFileAsync
          },
          _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrc
            },
            _.pick(orig, ['remote']),
            doc
            // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    it('does not identify the local move of a file following an unsynced child move as an addition', async function () {
      const orig = await builders
        .metafile()
        .path('SRC/FILE')
        .sides({ local: 2, remote: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const was = await builders
        .metafile()
        .path('DST/FILE')
        .moveFrom(orig)
        .sides({ local: 1 })
        .create()
      const doc = await builders
        .metafile()
        .path('DST/FILE2')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          // FIXME: extraneous DST document due to fake directory move
          {
            _id: 'DST',
            path: 'DST',
            docType: 'folder',
            sides: { local: 1 },
            tags: [],
            updated_at: doc.updated_at // XXX: It might fail if it takes longer to run moveFileAsync
          },
          _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { local: 1 },
              moveFrom: movedSrc
            },
            _.pick(orig, ['remote']),
            doc
            // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function () {
        const expectedRevNumber = 5 // up to date + delete + create + update side

        const banana = await builders
          .metafile()
          .path('banana')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, _.cloneDeep(BANANA), _.cloneDeep(banana))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber },
                path: BANANA.path,
                moveFrom: _.defaults(
                  {
                    sides: { [this.side]: 2, [otherSide(this.side)]: 2 },
                    moveTo: BANANA._id,
                    _deleted: true
                  },
                  banana
                )
              },
              _.omit(banana, ['_rev']) // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict with an existing file', async function () {
        await builders.metafile().path('QUX').create()
        const was = await builders.metafile().path('baz').upToDate().create()
        const doc = builders.metafile(was).path('qux').build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, _.pick(doc, ['path', 'remote'])]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function () {
        const expectedRevNumber = 1 // new unsynced document

        const banana = await builders
          .metafile()
          .path('banana')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, _.cloneDeep(BANANA), _.cloneDeep(banana))
        )

        const movedSrc = _.defaults(
          {
            moveTo: BANANA._id,
            _deleted: true
          },
          banana
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber },
                moveFrom: movedSrc
              },
              BANANA
              // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function () {
        const was = await builders
          .metafile()
          .path('baz')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        await builders
          .metafile()
          .path('QUX')
          .create()
        const doc = builders
          .metafile()
          .path('qux')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc._id,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: 1 },
                moveFrom: movedSrc
              },
              _.pick(was, ['remote']),
              doc
              // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('moveFolderAsync', function () {
    beforeEach('create parent directory', async function () {
      await builders.metadir().path('FOOBAR').upToDate().create()
    })

    it('saves the new folder and deletes the old one with hints for writers', async function () {
      const was = await builders
        .metadir()
        .path('FOOBAR/OLD')
        .ino(666)
        .tags('courge', 'quux')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const doc = builders
        .metadir()
        .path('FOOBAR/NEW')
        .tags('courge', 'quux')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrc
            },
            _.pick(was, ['ino', 'remote']),
            doc
            // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the destination exists', () => {
      let existing

      beforeEach(async function () {
        existing = await builders.metadir().path('DST_DIR').upToDate().create()
      })

      it('resolves a conflict', async function () {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const doc = builders
          .metadir(was)
          .path(existing.path)
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        const {_id: dstId, path: dstPath} = _.find(
          sideEffects.savedDocs,
          ({path}) => path.match(/conflict/)
        )

        const movedSrc = _.defaults(
          {
            moveTo: dstId,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                _id: dstId,
                path: dstPath,
                sides: { [this.side]: 1 },
                moveFrom: movedSrc
              },
              doc
              // TODO: Compare _revs
            )
          ],
          resolvedConflicts: [
            [this.side, _.pick(doc, ['path', 'remote'])]
          ]
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function () {
        const previous = await builders.metadir().path(path).create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function () {
        const expectedRevNumber = 4 // create + delete + create + update side

        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const doc = builders
          .metadir(was)
          .path(path)
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc._id,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber },
                moveFrom: movedSrc
              },
              _.pick(was, ['ino']),
              doc
              // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does not create conflict for local-only existing folder.', async function () {
      const existing = await builders
        .metadir()
        .path('DST_DIR')
        .sides({ [this.side]: 1 })
        .create()
      const was = await builders
        .metadir()
        .path('SRC_DIR')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const doc = builders
        .metadir(was)
        .path(existing.path)
        .noRev()
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrc,
              overwrite: existing
            },
            doc
            // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function () {
        const expectedRevNumber = 5 // up to date + delete + create + update side

        const apple = await builders
          .metadir()
          .path('apple')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, _.cloneDeep(APPLE), _.cloneDeep(apple))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber },
                moveFrom: _.defaults(
                  {
                    sides: { [this.side]: 2, [otherSide(this.side)]: 2 },
                    moveTo: APPLE._id,
                    _deleted: true
                  },
                  apple
                )
              },
              APPLE
              // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict when moving a synced folder to an existing path', async function () {
        await builders
          .metadir()
          .path('LINUX')
          .create()
        const torvalds = await builders
          .metadir()
          .path('torvalds')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .build()
        const linux = builders
          .metadir(torvalds)
          .path('linux')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, _.cloneDeep(linux), _.cloneDeep(torvalds))
        )

        should(sideEffects).deepEqual({
          savedDocs: [], // XXX: The conflict will be considered as a new change and merged later
          resolvedConflicts: [
            [this.side, _.pick(linux, ['path', 'remote'])]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function () {
        const expectedRevNumber = 1 // new unsynced document

        const apple = await builders
          .metadir()
          .path('apple')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, _.cloneDeep(APPLE), _.cloneDeep(apple))
        )

        const movedSrc = _.defaults(
          {
            moveTo: APPLE._id,
            _deleted: true
          },
          apple
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber },
                moveFrom: movedSrc
              },
              APPLE
              // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function () {
        await builders
          .metadir()
          .path('NUKEM')
          .create()
        const duke = await builders
          .metadir()
          .path('duke')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const nukem = builders
          .metadir(duke)
          .path('nukem')
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, _.cloneDeep(nukem), _.cloneDeep(duke))
        )

        const movedSrc = _.defaults(
          {
            moveTo: nukem._id,
            _deleted: true
          },
          duke
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: 1 },
                moveFrom: movedSrc
              },
              nukem
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('handles overwritten descendants', async function () {
      const srcDir = await builders
        .metadir()
        .path('src')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const srcFile = await builders
        .metafile()
        .path('src/file')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const oldDst = await builders
        .metadir()
        .path('dst')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const dstFile = await builders
        .metafile()
        .path('dst/file')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const dstDir = builders
        .metadir()
        .path('dst')
        .overwrite(oldDst)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(this.side, _.cloneDeep(dstDir), _.cloneDeep(srcDir))
      )

      const movedSrcDir = _.defaults(
        {
          moveTo: dstDir._id,
          _deleted: true
        },
        srcDir
      )
      const movedSrcFile = _.defaults(
        {
          moveTo: dstFile._id,
          childMove: true,
          _deleted: true
        },
        srcFile
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrcDir, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrcDir,
              overwrite: oldDst
            },
            _.pick(srcDir, ['remote']),
            _.omit(dstDir, ['_rev']) // TODO: Compare _revs
          ),
          _.omit(movedSrcFile, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrcFile
            },
            _.pick(srcFile, ['remote']),
            _.omit(dstFile, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('moveFolderRecursively', function () {
    it('moves the folder and files/folders inside it', async function () {
      const was = await builders
        .metadir()
        .path('my-folder')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const subdir = await builders
        .metadir()
        .path('my-folder/folder-9')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const subfile = await builders
        .metafile()
        .path('my-folder/file-9')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const doc = builders
        .metadir()
        .path('DESTINATION')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderRecursivelyAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

      const movedDir = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      const movedSubfile = _.defaults(
        {
          moveTo: metadata.id(movedPath(subfile)),
          childMove: true,
          _deleted: true
        },
        subfile
      )
      const movedSubdir = _.defaults(
        {
          moveTo: metadata.id(movedPath(subdir)),
          childMove: true,
          _deleted: true
        },
        subdir
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedDir, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedDir
            },
            doc
          ),
          _.omit(movedSubfile, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              _id: metadata.id(movedPath(subfile)),
              path: movedPath(subfile),
              sides: { [this.side]: 1 },
              moveFrom: movedSubfile
            },
            _.omit(subfile, ['_rev'])
          ),
          _.omit(movedSubdir, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              _id: metadata.id(movedPath(subdir)),
              path: movedPath(subdir),
              sides: { [this.side]: 1 },
              moveFrom: movedSubdir
            },
            _.omit(subdir, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('adds an unsynced file to the destination folder', async function () {
      const was = await builders
        .metadir()
        .path('ADDED_DIR')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .create()
      const unsyncedFile = await builders
        .metafile()
        .path('ADDED_DIR/unsynced-file')
        .sides({ [this.side]: 1 })
        .create()
      const doc = builders
        .metadir()
        .path('MOVED_DIR')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderRecursivelyAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

      const movedSrc = _.defaults(
        {
          moveTo: doc._id,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
          _.defaults(
            {
              sides: { [this.side]: 1 },
              moveFrom: movedSrc
            },
            doc
          ),
          _.defaults(
            {
              sides: { [this.side]: 2 },
              _deleted: true
            },
            _.omit(unsyncedFile, ['_rev']) // TODO: Compare _revs
          ),
          _.defaults(
            {
              _id: metadata.id(movedPath(unsyncedFile)),
              path: movedPath(unsyncedFile),
              sides: { [this.side]: 1 }
            },
            _.omit(unsyncedFile, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function () {
        const previous = await builders.metadir().path(path).create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function () {
        const expectedRevNumber = 4 // create + delete + create + update side

        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const doc = builders
          .metadir()
          .path(path)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc._id,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: expectedRevNumber },
                moveFrom: movedSrc
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the destination of a child has existed', () => {
      const parentPath = 'DST_DIR'
      const childName = 'CHILD'

      beforeEach(async function () {
        const previous = await builders.metadata().path(`${parentPath}/${childName}`).create()
        await this.pouch.remove(previous)
      })

      it('saves the new child with the correct side', async function () {
        const expectedRevNumber = 4 // create + delete + create + update side

        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const child = await builders
          .metadata()
          .path(`SRC_DIR/${childName}`)
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(parentPath)
          .noRev()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedDir = _.defaults(
          {
            moveTo: doc._id,
            _deleted: true
          },
          was
        )
        const movedChild = _.defaults(
          {
            moveTo: metadata.id(movedPath(child)),
            childMove: true,
            _deleted: true
          },
          child
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedDir, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: { [this.side]: 1 },
                moveFrom: movedDir
              },
              doc
            ),
            _.omit(movedChild, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                _id: metadata.id(movedPath(child)),
                path: movedPath(child),
                sides: { [this.side]: expectedRevNumber },
                moveFrom: movedChild
              },
              _.omit(child, ['_rev']) // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('trashFolderAsync', () => {
    it('does not trash a folder if the other side has added a new file in it', async function () {
      const was = await builders
        .metadir()
        .path('trashed-folder')
        .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
        .remoteId(dbBuilders.id())
        .trashed()
        .create()
      await builders
        .metafile()
        .path('trashed-folder/file')
        .sides({ [otherSide(this.side)]: 1 })
        .create()
      const doc = await builders
        .metadir(was)
        .path(`.cozy_trash/${was.path}`)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.trashFolderAsync(this.side, _.cloneDeep(was), _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [otherSide(this.side)]: 3 } // XXX: Why not resetting the side here?
            },
            _.omit(was, ['trashed', '_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('deleteFile', () => {
    it('deletes a file', async function () {
      const doc = await builders
        .metafile()
        .path('FILE')
        .data('content')
        .sides({ [this.side]: 1 })
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 2 }, // FIXME: Is that really necessary??
              _deleted: true
            },
            _.omit(doc, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('deleteFolder', function () {
    it('deletes a folder', async function () {
      const doc = await builders
        .metadir()
        .path('FOLDER')
        .sides({ [this.side]: 1 })
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 2 }, // FIXME: Is that really necessary??
              _deleted: true
            },
            _.omit(doc, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })

    it('removes nested content', async function () {
      const doc = await builders
        .metadir()
        .path('FOLDER')
        .sides({ [this.side]: 1 })
        .create()
      const subdir = await builders
        .metafile()
        .path('FOLDER/DIR')
        .sides({ [this.side]: 1 })
        .create()
      const subsubdir = await builders
        .metafile()
        .path('FOLDER/DIR/DIR')
        .sides({ [this.side]: 1 })
        .create()
      const subsubsubfile = await builders
        .metafile()
        .path('FOLDER/DIR/DIR/FILE')
        .sides({ [this.side]: 1 })
        .data('content')
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { [this.side]: 2 }, // FIXME: Is that really necessary??
              _deleted: true
            },
            _.omit(subsubsubfile, ['_rev']) // TODO: Compare _revs
          ),
          _.defaults(
            {
              sides: { [this.side]: 2 }, // FIXME: Is that really necessary??
              _deleted: true
            },
            _.omit(subsubdir, ['_rev']) // TODO: Compare _revs
          ),
          _.defaults(
            {
              sides: { [this.side]: 2 }, // FIXME: Is that really necessary??
              _deleted: true
            },
            _.omit(subdir, ['_rev']) // TODO: Compare _revs
          ),
          _.defaults(
            {
              sides: { [this.side]: 2 }, // FIXME: Is that really necessary??
              _deleted: true
            },
            _.omit(doc, ['_rev']) // TODO: Compare _revs
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('doTrash', () => {
    context('when metadata are found in Pouch', () => {
      it('deletes it with trashed property and up-to-date sides info', async function () {
        const was = await builders
          .metadata()
          .sides({ [this.side]: 2, [otherSide(this.side)]: 2 })
          .remoteId(dbBuilders.id())
          .create()
        const doc = builders
          .metadata(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.doTrash(this.side, _.cloneDeep(was), _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                _deleted: true,
                sides: { [this.side]: 3, [otherSide(this.side)]: 2 }
              },
              _.omit(was, ['_rev']) // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when metadata are not found in Pouch', () => {
      it('does nothing', async function () {
        const was = builders.metadata().build()
        const doc = builders.metadata(was).trashed().build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.doTrash(this.side, _.cloneDeep(was), _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when docType does not match', () => {
      it('does nothing', async function () {
        const was = await builders.metafile().create()
        const doc = builders.metadir().path(was.path).trashed().build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.doTrash(this.side, _.cloneDeep(was), _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })
  })
})
